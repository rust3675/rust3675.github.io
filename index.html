<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mechanical Ice Dragon Flight</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #05070a; }
        #canvas-container { width: 100vw; height: 100vh; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; font-family: 'Courier New', monospace; font-size: 1.2rem;
            text-shadow: 0 0 10px #00ffff; pointer-events: none; transition: opacity 0.5s;
        }
        .hidden { opacity: 0; }
    </style>
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Simplex Noise for terrain generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>
    <div id="loading">INITIALIZING SYSTEM...</div>
    <div id="canvas-container"></div>

    <script>
        // --- Configuration ---
        const CONFIG = {
            color: {
                background: 0x05070a,
                fog: 0x0b1016,
                dragonBlue: 0x1a3c5a, // Dark mechanical blue
                dragonSilver: 0x8899a6, // Brushed steel
                membrane: 0x4fd4d6, // Ice cyan
                eyeGlow: 0x00ffff,
                iceSpike: 0xa5f2f3
            },
            speed: 0.02
        };

        let scene, camera, renderer, dragon, snowSystem, terrain;
        let clock = new THREE.Clock();
        let mouse = { x: 0, y: 0 };

        // Initialize
        function init() {
            const container = document.getElementById('canvas-container');
            
            // Scene & Fog
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.color.background);
            scene.fog = new THREE.FogExp2(CONFIG.color.fog, 0.015);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 20);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            const blueBackLight = new THREE.DirectionalLight(0x0044ff, 0.8);
            blueBackLight.position.set(-50, 20, -50);
            scene.add(blueBackLight);

            // Build Scene Objects
            createTerrain();
            createSnow();
            dragon = new MechanicalDragon();
            scene.add(dragon.mesh);

            // Events
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);

            // Hide loader
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 1000);

            animate();
        }

        // --- Dragon Class ---
        class MechanicalDragon {
            constructor() {
                this.mesh = new THREE.Group();
                this.time = 0;
                
                // Materials
                this.armorMat = new THREE.MeshStandardMaterial({
                    color: CONFIG.color.dragonBlue,
                    metalness: 0.8,
                    roughness: 0.3,
                    flatShading: true
                });

                this.silverMat = new THREE.MeshStandardMaterial({
                    color: CONFIG.color.dragonSilver,
                    metalness: 0.9,
                    roughness: 0.4
                });

                this.iceMat = new THREE.MeshStandardMaterial({
                    color: CONFIG.color.iceSpike,
                    transparent: true,
                    opacity: 0.8,
                    roughness: 0.1,
                    metalness: 0.1,
                    emissive: 0x002233,
                    emissiveIntensity: 0.2
                });

                this.membraneMat = new THREE.MeshStandardMaterial({
                    color: CONFIG.color.membrane,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide,
                    metalness: 0.1,
                    roughness: 0.2
                });

                this.glowMat = new THREE.MeshBasicMaterial({
                    color: CONFIG.color.eyeGlow
                });

                this.buildBody();
            }

            buildBody() {
                // 1. Torso Group
                this.torso = new THREE.Group();
                this.mesh.add(this.torso);

                // Main Chest Plate (Armored Box)
                const chestGeo = new THREE.CylinderGeometry(1.8, 1.2, 4, 6);
                const chest = new THREE.Mesh(chestGeo, this.armorMat);
                chest.rotation.z = Math.PI / 2;
                chest.rotation.y = Math.PI / 6;
                chest.castShadow = true;
                this.torso.add(chest);

                // Hips
                const hipGeo = new THREE.CylinderGeometry(1.2, 0.8, 2.5, 6);
                const hips = new THREE.Mesh(hipGeo, this.silverMat);
                hips.rotation.z = Math.PI / 2;
                hips.position.x = -3;
                hips.castShadow = true;
                this.torso.add(hips);

                // Spikes on back
                for(let i=0; i<3; i++) {
                    const spike = new THREE.Mesh(new THREE.ConeGeometry(0.2, 1.5, 4), this.iceMat);
                    spike.position.y = 1.5;
                    spike.position.x = -1 + i * 1.2;
                    spike.rotation.x = -Math.PI / 6;
                    this.torso.add(spike);
                }

                // 2. Neck & Head
                this.neckSegments = [];
                let prevSegment = this.torso;
                let posX = 2.5;
                
                // Neck Chain
                for (let i = 0; i < 5; i++) {
                    const segGroup = new THREE.Group();
                    segGroup.position.set(i === 0 ? 2 : 0.8, i===0 ? 0.5: 0.2, 0); // Offset from previous
                    
                    const segGeo = new THREE.CylinderGeometry(0.8 - i*0.1, 0.7 - i*0.1, 1, 5);
                    const seg = new THREE.Mesh(segGeo, this.silverMat);
                    seg.rotation.z = Math.PI / 2;
                    seg.castShadow = true;
                    
                    // Add neck spikes
                    const nSpike = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.8, 3), this.iceMat);
                    nSpike.position.y = 0.5;
                    nSpike.rotation.x = -Math.PI/4;
                    seg.add(nSpike);

                    segGroup.add(seg);
                    prevSegment.add(segGroup);
                    prevSegment = segGroup;
                    this.neckSegments.push(segGroup);
                }

                // Head
                this.headGroup = new THREE.Group();
                this.headGroup.position.set(0.8, 0, 0);
                prevSegment.add(this.headGroup);

                // Skull
                const skull = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 0.9), this.armorMat);
                this.headGroup.add(skull);

                // Snout
                const snout = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 1.2, 5), this.armorMat);
                snout.rotation.z = Math.PI / 2;
                snout.position.x = 1;
                this.headGroup.add(snout);

                // Jaw
                const jaw = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 0.6), this.silverMat);
                jaw.position.set(0.5, -0.4, 0);
                jaw.rotation.z = 0.2;
                this.headGroup.add(jaw);

                // Eyes
                const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);
                const leftEye = new THREE.Mesh(eyeGeo, this.glowMat);
                const rightEye = new THREE.Mesh(eyeGeo, this.glowMat);
                leftEye.position.set(0.2, 0.2, 0.35);
                rightEye.position.set(0.2, 0.2, -0.35);
                this.headGroup.add(leftEye);
                this.headGroup.add(rightEye);

                // Eye Glow Light
                const eyeLight = new THREE.PointLight(CONFIG.color.eyeGlow, 1, 5);
                eyeLight.position.set(0.5, 0, 0);
                this.headGroup.add(eyeLight);

                // Head Horns
                const hornL = new THREE.Mesh(new THREE.ConeGeometry(0.1, 1.5, 4), this.iceMat);
                hornL.position.set(-0.5, 0.5, 0.4);
                hornL.rotation.z = Math.PI / 3;
                hornL.rotation.x = -0.2;
                this.headGroup.add(hornL);

                const hornR = hornL.clone();
                hornR.position.set(-0.5, 0.5, -0.4);
                hornR.rotation.x = 0.2;
                this.headGroup.add(hornR);


                // 3. Tail
                this.tailSegments = [];
                prevSegment = this.torso; // Start back at torso hips
                // Actually attach to hips object logic
                // We'll just chain from the hips position
                
                // Tail Chain
                let tailRoot = new THREE.Group();
                tailRoot.position.set(-4.2, 0, 0);
                this.torso.add(tailRoot);
                prevSegment = tailRoot;

                for(let i=0; i<12; i++) {
                    const tGroup = new THREE.Group();
                    tGroup.position.set(-0.8, 0, 0);

                    const size = 0.7 - (i * 0.05);
                    const tGeo = new THREE.CylinderGeometry(size, size*0.8, 1, 5);
                    const tSeg = new THREE.Mesh(tGeo, this.armorMat);
                    tSeg.rotation.z = Math.PI / 2;
                    tSeg.castShadow = true;
                    
                    // Tail spikes
                    if(i % 2 === 0) {
                        const tSpike = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.5 + size, 3), this.iceMat);
                        tSpike.position.y = size;
                        tGroup.add(tSpike);
                    }

                    tGroup.add(tSeg);
                    prevSegment.add(tGroup);
                    prevSegment = tGroup;
                    this.tailSegments.push(tGroup);
                }


                // 4. Wings
                this.leftWing = this.createWing(1);
                this.rightWing = this.createWing(-1);
                
                this.torso.add(this.leftWing);
                this.torso.add(this.rightWing);

            }

            createWing(side) {
                const wingGroup = new THREE.Group();
                // Position at shoulder
                wingGroup.position.set(1, 0.5, 0.8 * side);

                // 1. Humerus (Inner Wing Bone)
                const humerusL = 3;
                const humerusGeo = new THREE.BoxGeometry(humerusL, 0.4, 0.4);
                const humerus = new THREE.Mesh(humerusGeo, this.silverMat);
                humerus.position.set(0, 0, humerusL/2 * side); // Grow outward
                humerus.rotation.y = -0.2 * side;
                
                // Pivot wrapper
                const shoulderPivot = new THREE.Group();
                shoulderPivot.rotation.z = 0.5; // Initial lift
                shoulderPivot.rotation.y = -0.5 * side; // Sweep back
                
                // Re-center pivot logic
                const bone1 = new THREE.Group();
                bone1.add(humerus);
                // Adjust geometric center
                humerus.position.set(0, 0, humerusL/2 * side);
                
                shoulderPivot.add(bone1);
                wingGroup.add(shoulderPivot);

                // 2. Radius (Outer Wing Bone)
                const radiusL = 4;
                const radiusGeo = new THREE.BoxGeometry(radiusL, 0.3, 0.3);
                const radius = new THREE.Mesh(radiusGeo, this.silverMat);
                radius.position.set(0, 0, radiusL/2 * side);

                const elbowPivot = new THREE.Group();
                elbowPivot.position.set(0, 0, humerusL * side);
                elbowPivot.rotation.y = 0.5 * side; // Bend wing
                
                const bone2 = new THREE.Group();
                bone2.add(radius);
                elbowPivot.add(bone2);
                bone1.add(elbowPivot);

                // 3. Fingers & Membrane
                // We will create "fingers" radiating from the wrist (end of radius)
                const wristNode = new THREE.Group();
                wristNode.position.set(0, 0, radiusL * side);
                bone2.add(wristNode);

                const fingerLengths = [5, 4, 3, 2];
                const fingerAngles = [0.2, 0.8, 1.5, 2.0]; // Radians spread

                fingerLengths.forEach((len, i) => {
                    const fGeo = new THREE.CylinderGeometry(0.05, 0.02, len, 4);
                    const finger = new THREE.Mesh(fGeo, this.silverMat);
                    finger.position.set(0, 0, len/2 * side); // Length along Z initially
                    finger.rotation.x = Math.PI/2; // Pointing out
                    
                    const fPivot = new THREE.Group();
                    fPivot.rotation.y = fingerAngles[i] * side;
                    fPivot.add(finger);
                    wristNode.add(fPivot);

                    // Add Membrane patches between fingers
                    // Approximated with planes scaling between points is complex procedurally without custom geometry
                    // So we attach thin planes to the fingers themselves to simulate the "stretched" look
                    const memGeo = new THREE.PlaneGeometry(len, len/1.5);
                    const mem = new THREE.Mesh(memGeo, this.membraneMat);
                    mem.position.set(len/2, 0, 0); // Offset to hang off finger
                    mem.rotation.x = Math.PI/2;
                    mem.rotation.z = -0.2 * side; // Angle slightly back
                    
                    // Hack to make it look attached
                    fPivot.add(mem);
                });

                // Store references for animation
                wingGroup.userData = {
                    shoulder: shoulderPivot,
                    elbow: elbowPivot,
                    wrist: wristNode,
                    side: side
                };

                return wingGroup;
            }

            update(t, delta) {
                this.time += delta;

                // 1. Body Undulation (Sine wave flight)
                this.mesh.position.y = Math.sin(this.time * 2) * 1.5;
                this.mesh.rotation.z = Math.sin(this.time * 1) * 0.1; // Slight Roll
                this.mesh.rotation.x = Math.sin(this.time * 1.5) * 0.05; // Pitch

                // 2. Wing Flapping
                const flapSpeed = 4;
                const flapAmp = 0.6;
                const flapOffset = Math.sin(this.time * flapSpeed);

                [this.leftWing, this.rightWing].forEach(wing => {
                    const s = wing.userData.side;
                    
                    // Shoulder Flap
                    wing.userData.shoulder.rotation.z = (0.5 + flapOffset * flapAmp) * s * -1; // Invert for correct up/down
                    
                    // Elbow secondary motion (lagging behind shoulder)
                    wing.userData.elbow.rotation.z = Math.sin(this.time * flapSpeed - 1) * 0.3 * s;

                    // Wrist spread
                    wing.userData.wrist.rotation.z = Math.sin(this.time * flapSpeed - 2) * 0.2 * s;
                });

                // 3. Neck Sinuous Motion
                this.neckSegments.forEach((seg, i) => {
                    seg.rotation.y = Math.sin(this.time * 2 + i * 0.5) * 0.1;
                    seg.rotation.z = Math.sin(this.time * 2 + i * 0.5) * 0.05;
                });
                
                // Head follows neck but stabilizes
                this.headGroup.rotation.y = Math.sin(this.time * 2 + 5 * 0.5) * 0.1;
                
                // Jaw movement (breathing)
                this.headGroup.children[2].rotation.z = 0.2 + Math.sin(this.time * 5) * 0.05;

                // 4. Tail Whipping
                this.tailSegments.forEach((seg, i) => {
                    // Increasing amplitude towards tip
                    const amp = 0.1 + (i * 0.02);
                    seg.rotation.y = Math.sin(this.time * 3 - i * 0.4) * amp;
                    seg.rotation.z = Math.cos(this.time * 3 - i * 0.4) * (amp * 0.5);
                });
            }
        }

        // --- Environment ---

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            
            // Simple noise generation for jagged peaks
            const simplex = new SimplexNoise();
            const posAttribute = geometry.attributes.position;
            
            for (let i = 0; i < posAttribute.count; i++) {
                const x = posAttribute.getX(i);
                const y = posAttribute.getY(i);
                
                // Layered noise for detail
                let z = simplex.noise2D(x * 0.02, y * 0.02) * 10;
                z += simplex.noise2D(x * 0.1, y * 0.1) * 2;
                
                // Make it jagged (absolute value creates sharp creases)
                z = Math.abs(z);
                
                // Raise mountains at edges
                const dist = Math.sqrt(x*x + y*y);
                if(dist > 20) z += (dist - 20) * 0.5;

                posAttribute.setZ(i, z - 20); // Push down so dragon flies above
            }

            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.9,
                metalness: 0.1,
                flatShading: true
            });

            terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            scene.add(terrain);
        }

        function createSnow() {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 100
                );
                velocities.push(
                    (Math.random() - 0.5) * 0.2, // X drift
                    -Math.random() * 0.5 - 0.1,  // Y fall speed
                    (Math.random() - 0.5) * 0.2  // Z drift
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });

            snowSystem = new THREE.Points(geometry, material);
            snowSystem.userData = { velocities: velocities };
            scene.add(snowSystem);
        }

        function updateSnow() {
            const positions = snowSystem.geometry.attributes.position.array;
            const velocities = snowSystem.userData.velocities;

            for (let i = 0; i < positions.length; i += 3) {
                // Update position
                positions[i] += velocities[i] - 0.1; // Wind pushes left
                positions[i + 1] += velocities[i + 1];
                positions[i + 2] += velocities[i + 2];

                // Reset if out of bounds
                if (positions[i + 1] < -20) {
                    positions[i] = (Math.random() - 0.5) * 100;
                    positions[i + 1] = 30;
                    positions[i + 2] = (Math.random() - 0.5) * 100;
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
        }

        // --- Main Loop ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            // Normalize mouse position
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (dragon) {
                dragon.update(time, delta);
                
                // Camera interaction
                const targetX = mouse.x * 10;
                const targetY = mouse.y * 5 + 5;
                
                // Smooth camera follow
                camera.position.x += (targetX - camera.position.x) * 0.05;
                camera.position.y += (targetY - camera.position.y) * 0.05;
                camera.lookAt(dragon.mesh.position);
            }

            // Move terrain to simulate forward flight
            if (terrain) {
                terrain.position.x += 0.2;
                if(terrain.position.x > 10) terrain.position.x = 0; // Loop terrain texture pos (rough approximation)
                // Actually moving the mesh is choppy, better to move texture, 
                // but since we used vertex displacement, we can just translate the whole group back periodically
                // or move the dragon forward and camera forward.
                // Let's keep dragon static and move snow/camera logic implies movement.
            }
            
            updateSnow();
            
            renderer.render(scene, camera);
        }

        // Start
        init();

    </script>
</body>
</html>
