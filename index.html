<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>冰霜飞龙 - Frost Wyvern</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-family: 'Courier New', Courier, monospace;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>
<body>
    <div id="loading">正在召唤冰霜飞龙...</div>
    <!-- 引入 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- 场景初始化 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x051020); // 深蓝黑色背景
        scene.fog = new THREE.FogExp2(0x051020, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 + 0.2; // 限制不能看太低

        // --- 灯光系统 ---
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // 基础环境光
        scene.add(ambientLight);

        // 主光源 (冷色调太阳)
        const sunLight = new THREE.DirectionalLight(0xaaddff, 3);
        sunLight.position.set(10, 20, 10);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // 底部反射光 (冰面反射)
        const bottomLight = new THREE.DirectionalLight(0x00ffff, 1);
        bottomLight.position.set(0, -10, 5);
        scene.add(bottomLight);

        // --- 材质定义 ---
        // 1. 龙鳞/铠甲材质 (金属蓝)
        const armorMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x2C75FF,        // 冰蓝色
            emissive: 0x001133,
            metalness: 0.8,
            roughness: 0.2,
            clearcoat: 1.0,         // 像冰一样的涂层
            clearcoatRoughness: 0.1,
            flatShading: true       // 开启平面着色，增强棱角感 (替代圆柱的光滑感)
        });

        // 2. 冰刺/骨骼材质 (半透明发光)
        const iceSpikeMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xAAFFFF,
            metalness: 0.1,
            roughness: 0.1,
            transmission: 0.6,      // 透光
            thickness: 2.0,
            opacity: 0.9,
            transparent: true,
            emissive: 0x004444,
            emissiveIntensity: 0.2
        });

        // 3. 眼睛发光材质
        const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x00FFFF });

        // 4. 翼膜材质 (深色破损感)
        const wingMembraneMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x335588,
            metalness: 0.5,
            roughness: 0.7,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.9
        });

        // --- 几何体构建辅助函数 ---

        // 创建尖刺 (替代圆锥，使用拉长的四面体，更像冰晶)
        function createCrystalSpike(width, height, material) {
            const geometry = new THREE.TetrahedronGeometry(1, 0);
            geometry.scale(width, height, width);
            // 随机旋转一点顶点让它看起来不那么规则
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            return mesh;
        }

        // 创建铠甲板 (使用ExtrudeGeometry替代简单的Box)
        function createArmorPlate(width, length, depth, material) {
            const shape = new THREE.Shape();
            // 绘制一个六边形或不规则多边形作为截面
            shape.moveTo(0, width/2);
            shape.lineTo(length/2, width);
            shape.lineTo(length, width/2);
            shape.lineTo(length/2, 0);
            shape.lineTo(0, 0);

            const extrudeSettings = {
                steps: 1,
                depth: depth,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 1
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.center(); // 居中
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        // --- 飞龙组装 (Procedural Dragon) ---
        const dragonGroup = new THREE.Group();
        scene.add(dragonGroup);

        // 1. 躯干 (Torso) - 由多个铠甲板层叠组成
        const torsoGroup = new THREE.Group();
        dragonGroup.add(torsoGroup);

        for (let i = 0; i < 4; i++) {
            const rib = createArmorPlate(1.5 - (i*0.2), 2.5, 1.8, armorMaterial);
            rib.position.set(0, 0, i * 1.2 - 1.5);
            rib.rotation.x = Math.PI / 2;
            rib.scale.set(1, 1, 1 - i*0.1);
            torsoGroup.add(rib);
            
            // 胸口发光核心
            if(i===1) {
                const coreLight = new THREE.PointLight(0x00ffff, 2, 5);
                rib.add(coreLight);
            }
        }

        // 2. 脖子 (Neck) - 链式结构
        const neckBones = [];
        let currentParent = torsoGroup;
        const neckLength = 6;
        
        for (let i = 0; i < neckLength; i++) {
            const neckSegmentGroup = new THREE.Group();
            // 脖子位置偏移
            neckSegmentGroup.position.set(0, 0.8, -0.5); 
            if (i === 0) neckSegmentGroup.position.set(0, 1.5, -1.5); // 连接躯干点

            // 脖子主体 (复杂的结晶状)
            const segmentGeo = new THREE.IcosahedronGeometry(0.6 - (i * 0.05), 0);
            const segment = new THREE.Mesh(segmentGeo, armorMaterial);
            segment.castShadow = true;
            neckSegmentGroup.add(segment);

            // 脖子上的冰刺 (替代鬃毛)
            const spike = createCrystalSpike(0.2, 1.0, iceSpikeMaterial);
            spike.position.set(0, 0.6, 0);
            spike.rotation.x = -Math.PI / 4;
            neckSegmentGroup.add(spike);

            currentParent.add(neckSegmentGroup);
            currentParent = neckSegmentGroup; // 链式连接
            neckBones.push(neckSegmentGroup);
        }

        // 3. 头部 (Head) - 接在脖子末端
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 0.8, -0.5);
        currentParent.add(headGroup);

        // 头盖骨 (棱角分明)
        const skullGeo = new THREE.BufferGeometry();
        // 手动构建一个简单的低多边形龙头形状顶点 (这里简化用Octahedron变形)
        const headMain = new THREE.Mesh(new THREE.OctahedronGeometry(0.8, 0), armorMaterial);
        headMain.scale.set(0.8, 0.6, 1.5);
        headGroup.add(headMain);

        // 下颚
        const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 1.2), armorMaterial);
        jaw.position.set(0, -0.4, 0.2);
        jaw.rotation.x = 0.2;
        headGroup.add(jaw);

        // 眼睛 (Glowing Eyes)
        const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.1, 0.2), eyeMaterial);
        leftEye.position.set(0.35, 0.1, 0.5);
        headGroup.add(leftEye);
        const rightEye = leftEye.clone();
        rightEye.position.set(-0.35, 0.1, 0.5);
        headGroup.add(rightEye);
        
        // 眼睛点光源
        const eyeLight = new THREE.PointLight(0x00ffff, 1, 2);
        eyeLight.position.set(0, 0.1, 0.8);
        headGroup.add(eyeLight);

        // 头上的角 (Horns)
        const leftHorn = createCrystalSpike(0.15, 1.5, iceSpikeMaterial);
        leftHorn.position.set(0.3, 0.5, -0.5);
        leftHorn.rotation.x = -0.5;
        headGroup.add(leftHorn);
        const rightHorn = leftHorn.clone();
        rightHorn.position.set(-0.3, 0.5, -0.5);
        headGroup.add(rightHorn);

        // 4. 尾巴 (Tail) - 链式结构
        const tailBones = [];
        currentParent = torsoGroup;
        const tailLength = 12;

        for (let i = 0; i < tailLength; i++) {
            const tailSegGroup = new THREE.Group();
            tailSegGroup.position.set(0, i===0 ? -0.5 : 0, i===0 ? 1.5 : 0.8); // 向后延伸

            const s = 1 - (i / tailLength); // 逐渐变小
            const segMesh = new THREE.Mesh(new THREE.OctahedronGeometry(0.5 * s, 0), armorMaterial);
            tailSegGroup.add(segMesh);

            // 尾巴两侧的冰刺
            if (i % 2 === 0) {
                const sideSpikeL = createCrystalSpike(0.1*s, 0.6*s, iceSpikeMaterial);
                sideSpikeL.position.set(0.3*s, 0, 0);
                sideSpikeL.rotation.z = -Math.PI/2;
                tailSegGroup.add(sideSpikeL);
                
                const sideSpikeR = createCrystalSpike(0.1*s, 0.6*s, iceSpikeMaterial);
                sideSpikeR.position.set(-0.3*s, 0, 0);
                sideSpikeR.rotation.z = Math.PI/2;
                tailSegGroup.add(sideSpikeR);
            }

            currentParent.add(tailSegGroup);
            currentParent = tailSegGroup;
            tailBones.push(tailSegGroup);
        }

        // 5. 翅膀 (Wings) - 复杂的骨架 + 破碎的膜
        function createDetailedWing(isLeft) {
            const wingGroup = new THREE.Group();
            const dir = isLeft ? 1 : -1;

            // 翅膀根部关节
            const shoulder = new THREE.Mesh(new THREE.IcosahedronGeometry(0.5, 0), armorMaterial);
            wingGroup.add(shoulder);

            // 主翼骨 (Arm)
            const armLength = 4;
            const armBone = createArmorPlate(0.3, armLength, 0.3, armorMaterial);
            armBone.position.set(dir * armLength/2, 0, 0);
            armBone.rotation.z = dir * 0.2;
            shoulder.add(armBone);

            // 前臂 (Forearm)
            const forearmLength = 5;
            const forearmGroup = new THREE.Group();
            forearmGroup.position.set(dir * armLength * 0.9, 0, 0); // 连接点
            forearmGroup.rotation.z = dir * 0.5; // 折叠角度
            shoulder.add(forearmGroup); // 这里简化，直接挂在shoulder层级以便后续动画，或者挂在armBone末端

            const forearmBone = createArmorPlate(0.25, forearmLength, 0.2, armorMaterial);
            forearmBone.position.set(dir * forearmLength/2, 0, 0);
            forearmGroup.add(forearmBone);

            // 翼指 (Fingers) - 像雨伞骨架
            const fingers = [];
            for(let i=0; i<3; i++) {
                const fingerLen = 4 + i;
                const finger = createCrystalSpike(0.05, fingerLen, armorMaterial);
                finger.position.set(dir * forearmLength, 0, 0); // 从前臂末端长出
                // 展开角度
                finger.rotation.z = dir * (Math.PI / 2 + (i * 0.5)); 
                forearmGroup.add(finger);
                fingers.push(finger);
            }

            // 翼膜 (Membrane) - 使用自定义Shape来模拟破损
            const membraneShape = new THREE.Shape();
            membraneShape.moveTo(0, 0); // 前臂末端
            
            // 绘制一个带锯齿的路径连接各个指尖
            // 注意：这里只是简化模拟，真实的动态翼膜需要蒙皮动画，这里用静态几何体模拟展开状态
            const pts = [];
            pts.push(new THREE.Vector2(0,0));
            pts.push(new THREE.Vector2(dir * -2, -3)); // 第一指尖大概位置
            pts.push(new THREE.Vector2(dir * -1, -2)); // 锯齿缺口
            pts.push(new THREE.Vector2(dir * -3, -5)); // 第二指尖
            pts.push(new THREE.Vector2(dir * -2.5, -3.5)); // 锯齿缺口
            pts.push(new THREE.Vector2(dir * -5, -6)); // 第三指尖
            pts.push(new THREE.Vector2(dir * -4, 1)); // 回到根部附近

            const membraneGeo = new THREE.ShapeGeometry(new THREE.Shape(pts));
            const membrane = new THREE.Mesh(membraneGeo, wingMembraneMaterial);
            membrane.position.set(dir * forearmLength, 0, 0); // 挂在前臂末端
            forearmGroup.add(membrane);

            return { group: wingGroup, forearm: forearmGroup };
        }

        const leftWingObj = createDetailedWing(true);
        leftWingObj.group.position.set(1.2, 1, -0.5);
        leftWingObj.group.rotation.z = -0.2;
        leftWingObj.group.rotation.y = -0.2;
        torsoGroup.add(leftWingObj.group);

        const rightWingObj = createDetailedWing(false);
        rightWingObj.group.position.set(-1.2, 1, -0.5);
        rightWingObj.group.rotation.z = 0.2;
        rightWingObj.group.rotation.y = 0.2;
        torsoGroup.add(rightWingObj.group);


        // 6. 腿部 (Legs) - 猛禽结构
        function createLeg(isLeft) {
            const legGroup = new THREE.Group();
            const dir = isLeft ? 1 : -1;

            // 大腿
            const thigh = new THREE.Mesh(new THREE.OctahedronGeometry(0.7, 0), armorMaterial);
            thigh.scale.set(0.8, 1.2, 0.8);
            legGroup.add(thigh);

            // 小腿
            const shin = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.5, 0.4), armorMaterial);
            shin.position.set(0, -1.2, 0.5);
            shin.rotation.x = -0.4;
            legGroup.add(shin);

            // 爪子
            const clawGroup = new THREE.Group();
            clawGroup.position.set(0, -2.0, 0.8);
            legGroup.add(clawGroup);

            // 三根脚趾
            for(let k=-1; k<=1; k++) {
                const toe = createCrystalSpike(0.1, 0.6, iceSpikeMaterial);
                toe.rotation.x = Math.PI/2;
                toe.rotation.z = k * 0.5;
                toe.position.set(k*0.2, 0, 0);
                clawGroup.add(toe);
            }

            return legGroup;
        }

        const leftLeg = createLeg(true);
        leftLeg.position.set(1, -1, 1);
        torsoGroup.add(leftLeg);

        const rightLeg = createLeg(false);
        rightLeg.position.set(-1, -1, 1);
        torsoGroup.add(rightLeg);


        // --- 环境粒子系统 (Snow/Ice Dust) ---
        const particleCount = 1500;
        const particlesGeometry = new THREE.BufferGeometry();
        const particlePositions = [];
        const particleSpeeds = [];

        for (let i = 0; i < particleCount; i++) {
            const x = (Math.random() - 0.5) * 40;
            const y = (Math.random() - 0.5) * 40;
            const z = (Math.random() - 0.5) * 40;
            particlePositions.push(x, y, z);
            particleSpeeds.push(Math.random() * 0.05 + 0.02);
        }

        particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);

        // --- 底部冰台 ---
        const icePlatformGeo = new THREE.CylinderGeometry(8, 8, 0.2, 6); // 这里的圆柱仅用于底座，不用于龙
        const icePlatformMat = new THREE.MeshPhysicalMaterial({
            color: 0x88ccff,
            transmission: 0.8,
            opacity: 0.8,
            roughness: 0.1,
            metalness: 0.1,
            transparent: true
        });
        const platform = new THREE.Mesh(icePlatformGeo, icePlatformMat);
        platform.position.y = -6;
        scene.add(platform);
        
        // 底座上的尖刺
        for(let i=0; i<10; i++) {
            const pSpike = createCrystalSpike(0.5, 2 + Math.random(), iceSpikeMaterial);
            const angle = Math.random() * Math.PI * 2;
            const rad = Math.random() * 6;
            pSpike.position.set(Math.cos(angle)*rad, -5, Math.sin(angle)*rad);
            scene.add(pSpike);
        }


        // --- 后处理 (Bloom Effect) ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 0.6; // 发光强度
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- 动画循环 ---
        document.getElementById('loading').style.display = 'none';

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const delta = clock.getDelta();

            // 1. 全局浮动
            dragonGroup.position.y = Math.sin(time * 1.5) * 0.5;

            // 2. 翅膀扇动
            const wingSpeed = 3;
            const flapAngle = Math.sin(time * wingSpeed) * 0.4; // 扇动幅度
            
            // 左翼
            leftWingObj.group.rotation.z = -0.2 + flapAngle; 
            leftWingObj.forearm.rotation.z = 0.5 + flapAngle * 0.5; // 前臂跟随延迟

            // 右翼
            rightWingObj.group.rotation.z = 0.2 - flapAngle;
            rightWingObj.forearm.rotation.z = -0.5 - flapAngle * 0.5;

            // 3. 脖子像蛇一样蠕动 (Wave motion)
            neckBones.forEach((bone, index) => {
                bone.rotation.x = Math.sin(time * 2 + index * 0.5) * 0.1;
                bone.rotation.y = Math.cos(time * 1.5 + index * 0.3) * 0.1;
            });

            // 4. 尾巴摆动 (Wave motion)
            tailBones.forEach((bone, index) => {
                bone.rotation.y = Math.sin(time * 2 - index * 0.4) * 0.15;
                bone.rotation.x = Math.cos(time * 1.5 - index * 0.4) * 0.05;
            });

            // 5. 粒子下落
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] -= particleSpeeds[(i-1)/3];
                if (positions[i] < -10) {
                    positions[i] = 10;
                }
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.rotation.y = time * 0.05;

            // 渲染
            composer.render();
        }

        // 窗口调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
