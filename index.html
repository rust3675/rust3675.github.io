<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>愤怒的小鸟 3D (Three.js + Cannon.js)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #87CEEB; /* 天空蓝 */
            user-select: none;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none; /* 让鼠标事件穿透到 Canvas */
        }
        h1 {
            margin: 0;
            font-size: 24px;
        }
        p {
            margin: 5px 0;
            font-size: 16px;
        }
        #score-display {
            font-size: 32px;
            font-weight: bold;
            color: #FFD700;
        }
        #reset-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #ff4757;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            pointer-events: auto;
        }
        #reset-btn:hover {
            background-color: #ff6b81;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>愤怒的小鸟 3D</h1>
        <p>拖动红色小鸟并释放来攻击！</p>
        <p>得分: <span id="score-display">0</span></p>
    </div>
    <button id="reset-btn" onclick="window.resetGame()">重置关卡</button>
    <div id="loading">加载物理引擎中...</div>

    <!-- 使用 ES Modules 引入 Three.js 和 Cannon-es -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        // --- 变量声明 ---
        let scene, camera, renderer, controls;
        let world; // 物理世界
        let timeStep = 1 / 60;
        let lastCallTime;

        // 游戏对象数组 (同步 物理Body 和 渲染Mesh)
        let objectsToUpdate = [];
        let pigs = [];
        
        // 游戏状态
        let isDragging = false;
        let birdMesh, birdBody;
        let slingshotPos = new THREE.Vector3(-10, 5, 0);
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let dragPlane; // 用于拖拽的不可见平面
        let score = 0;
        let birdFired = false;

        // 资源材质
        const materials = {};

        // 初始化
        init();
        animate();

        function init() {
            // 1. Three.js 场景设置
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // 天空颜色
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

            // 摄像机
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 35);
            camera.lookAt(0, 5, 0);

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // 灯光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(-10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            scene.add(dirLight);

            // 2. Cannon.js 物理世界设置
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); // 重力
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            
            // 开启休眠：让静止的物体进入休眠状态，提高稳定性，防止微小抖动导致的倒塌
            world.allowSleep = true;

            // 物理材质
            const defaultMaterial = new CANNON.Material('default');
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
                friction: 0.5,    // 增加一点摩擦力，防止滑动
                restitution: 0.2, // 稍微降低弹性，减少反弹
            });
            world.addContactMaterial(defaultContactMaterial);

            // 3. 创建游戏环境
            createMaterials();
            createGround();
            createSlingshot();
            createLevel(); // 创建猪和砖块
            createBird();  // 创建小鸟

            // 拖拽辅助平面 (Z=0)
            dragPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            scene.add(dragPlane);

            // 事件监听
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            
            // 触摸支持
            window.addEventListener('touchstart', onTouchStart, {passive: false});
            window.addEventListener('touchmove', onTouchMove, {passive: false});
            window.addEventListener('touchend', onMouseUp);

            // 移除加载文字
            document.getElementById('loading').style.display = 'none';
            
            // 全局重置函数
            window.resetGame = resetGame;
        }

        function createMaterials() {
            materials.wood = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            materials.stone = new THREE.MeshStandardMaterial({ color: 0x808080 });
            materials.pig = new THREE.MeshStandardMaterial({ color: 0x7CFC00 });
            materials.bird = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
            materials.ground = new THREE.MeshStandardMaterial({ color: 0x228B22 });
        }

        function createGround() {
            // Three.js 地面
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMesh = new THREE.Mesh(groundGeo, materials.ground);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Cannon.js 地面
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 }); // mass 0 = 静态
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);
        }

        function createSlingshot() {
            // 简单的弹弓视觉模型 (Y型)
            const mat = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
            
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 5), mat);
            base.position.set(slingshotPos.x, 2.5, slingshotPos.z);
            base.castShadow = true;
            scene.add(base);

            const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 3), mat);
            leftArm.position.set(slingshotPos.x - 0.8, 5.5, slingshotPos.z);
            leftArm.rotation.z = Math.PI / 6;
            scene.add(leftArm);

            const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 3), mat);
            rightArm.position.set(slingshotPos.x + 0.8, 5.5, slingshotPos.z);
            rightArm.rotation.z = -Math.PI / 6;
            scene.add(rightArm);
        }

        function createBox(x, y, z, w, h, d, mass, material) {
            // Three.js
            const geometry = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Cannon.js
            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
            const body = new CANNON.Body({ mass: mass });
            body.addShape(shape);
            body.position.set(x, y, z);
            world.addBody(body);

            // 同步对象
            objectsToUpdate.push({ mesh, body });
            return body;
        }

        function createPig(x, y, z) {
            const radius = 0.8;
            
            // Visuals
            const geometry = new THREE.SphereGeometry(radius, 16, 16);
            const mesh = new THREE.Mesh(geometry, materials.pig);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            
            // 添加眼睛和鼻子让它看起来像猪
            const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({color:0xffffff});
            const pupilMat = new THREE.MeshBasicMaterial({color:0x000000});
            const noseGeo = new THREE.SphereGeometry(0.25, 8, 8);
            const noseMat = new THREE.MeshBasicMaterial({color:0x32CD32}); // 深绿

            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.3, 0.2, 0.6);
            mesh.add(leftEye);
            const leftPupil = new THREE.Mesh(new THREE.SphereGeometry(0.07), pupilMat);
            leftPupil.position.set(0,0,0.14);
            leftEye.add(leftPupil);

            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.3, 0.2, 0.6);
            mesh.add(rightEye);
            const rightPupil = new THREE.Mesh(new THREE.SphereGeometry(0.07), pupilMat);
            rightPupil.position.set(0,0,0.14);
            rightEye.add(rightPupil);

            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.set(0, -0.1, 0.7);
            mesh.add(nose);

            scene.add(mesh);

            // Physics
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({ mass: 2 });
            body.addShape(shape);
            body.position.set(x, y, z);
            world.addBody(body);

            // 监听碰撞
            body.addEventListener("collide", (e) => {
                // 修复逻辑：只有当鸟被发射后，才允许猪受到伤害
                // 这防止了关卡初始化时物体微小位移或重叠导致的误判
                if (!birdFired) return;

                // 计算碰撞强度
                const relativeVelocity = e.contact.getImpactVelocityAlongNormal();
                
                // 稍微提高了碰撞阈值 (5 -> 8)，防止轻轻一碰就死
                if(Math.abs(relativeVelocity) > 8) {
                    removePig(mesh, body);
                }
            });

            objectsToUpdate.push({ mesh, body });
            pigs.push({ mesh, body });
        }

        function createBird() {
            if(birdMesh) scene.remove(birdMesh);
            if(birdBody) world.removeBody(birdBody);
            birdFired = false;

            const radius = 0.6;
            
            // 视觉
            const geometry = new THREE.SphereGeometry(radius, 16, 16);
            birdMesh = new THREE.Mesh(geometry, materials.bird);
            birdMesh.castShadow = true;
            // 初始位置在弹弓中心
            birdMesh.position.copy(slingshotPos);
            birdMesh.position.y += 1.5; 
            scene.add(birdMesh);

            // 物理 (一开始不添加到世界，或者设为静态，直到发射)
            // 我们这里先不创建物理实体，直到发射的那一刻，
            // 或者创建一个 Static Body 跟随鼠标，发射时切换为 Dynamic
        }

        function createLevel() {
            const startX = 10;
            
            // --- 重新计算堆叠坐标，防止重叠 ---
            
            // 1. 底层柱子 (石头)
            // 高度: 4, Y中心: 0 + 2 = 2. 顶部Y: 4
            createBox(startX, 2, 0, 1, 4, 1, 5, materials.stone);
            createBox(startX + 6, 2, 0, 1, 4, 1, 5, materials.stone);
            
            // 2. 第一层横梁 (木头)
            // 放置在Y=4之上. 高度: 0.5. Y中心: 4 + 0.25 = 4.25. 顶部Y: 4.5
            createBox(startX + 3, 4.25, 0, 8, 0.5, 1, 2, materials.wood);

            // 中间的小猪 (在地面)
            // 半径0.8. Y中心: 0.8
            createPig(startX + 3, 0.8, 0);

            // 3. 第二层柱子 (木头) - 单根
            // 放置在Y=4.5之上. 高度: 4. Y中心: 4.5 + 2 = 6.5. 顶部Y: 8.5
            createBox(startX + 3, 6.5, 0, 1, 4, 1, 1, materials.wood);

            // 4. 顶层横梁 (木头)
            // 放置在Y=8.5之上. 高度: 0.5. Y中心: 8.5 + 0.25 = 8.75. 顶部Y: 9
            createBox(startX + 3, 8.75, 0, 4, 0.5, 1, 1, materials.wood);
            
            // 5. 顶层小猪
            // 放置在Y=9之上. 半径0.8. Y中心: 9 + 0.8 = 9.8
            createPig(startX + 3, 9.8, 0);

            // 6. 旁边的一堆箱子 (右侧)
            // 箱子1: 高2. Y中心: 1. 顶部Y: 2
            createBox(startX + 8, 1, 0, 2, 2, 2, 1, materials.wood);
            // 箱子2: 放置在Y=2之上. 高2. Y中心: 2 + 1 = 3. 顶部Y: 4
            createBox(startX + 8, 3, 0, 2, 2, 2, 1, materials.wood);
            // 旁边的猪: 放置在Y=4之上. Y中心: 4 + 0.8 = 4.8
            createPig(startX + 8, 4.8, 0);
        }

        function fireBird(position, velocity) {
            const radius = 0.6;
            
            // 创建物理身体
            const shape = new CANNON.Sphere(radius);
            birdBody = new CANNON.Body({ mass: 5 });
            birdBody.addShape(shape);
            birdBody.position.copy(position);
            birdBody.velocity.copy(velocity);
            
            world.addBody(birdBody);
            objectsToUpdate.push({ mesh: birdMesh, body: birdBody });
            birdFired = true;
        }

        function removePig(mesh, body) {
            // 简单的防抖，防止多次触发
            if(mesh.userData.isRemoved) return;
            mesh.userData.isRemoved = true;

            // 增加分数
            score += 100;
            document.getElementById('score-display').innerText = score;

            // 延迟移除，或者添加特效
            // 这里简单起见，直接下一帧移除
            setTimeout(() => {
                scene.remove(mesh);
                world.removeBody(body);
                // 从更新数组中移除
                const idx = objectsToUpdate.findIndex(o => o.mesh === mesh);
                if(idx > -1) objectsToUpdate.splice(idx, 1);
                
                // 检查是否全部消灭
                pigs = pigs.filter(p => p.mesh !== mesh);
                if(pigs.length === 0) {
                    setTimeout(() => alert("胜利！所有猪都被消灭了！"), 100);
                }
            }, 0);
        }

        function resetGame() {
            // 清理现有物体
            for(const obj of objectsToUpdate) {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            }
            objectsToUpdate = [];
            pigs = [];
            score = 0;
            document.getElementById('score-display').innerText = score;

            // 重建
            createGround(); // 地面 body 之前被删了吗？如果没有，这步要小心重复添加
            // 简单的做法：只删除 dynamic bodies
            // 更好的做法：刷新页面或重新调用初始化逻辑。
            // 这里简单处理：重建 Level 和 Bird
            
            // 注意：createGround 里的 static body 其实没被清除，因为上面的循环清的是 objectsToUpdate
            // 而 ground body 没在那个数组里。所以不需要重建 Ground 和 Slingshot。
            
            createLevel();
            createBird();
        }

        // --- 输入处理 ---

        function getRayIntersection(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(dragPlane);
            if(intersects.length > 0) return intersects[0].point;
            return null;
        }

        function onMouseDown(event) {
            if(birdFired) return;
            const point = getRayIntersection(event.clientX, event.clientY);
            if (point) {
                // 检查是否点到了鸟附近
                const dist = point.distanceTo(birdMesh.position);
                if(dist < 3) {
                    isDragging = true;
                    controls && (controls.enabled = false); // 禁用轨道控制器
                }
            }
        }
        
        // 触摸开始
        function onTouchStart(event) {
             if(event.touches.length > 0) {
                 const t = event.touches[0];
                 // 模拟 MouseDown 逻辑
                 if(birdFired) return;
                 const point = getRayIntersection(t.clientX, t.clientY);
                 if (point) {
                     const dist = point.distanceTo(birdMesh.position);
                     if(dist < 3) {
                         isDragging = true;
                         controls && (controls.enabled = false);
                     }
                 }
             }
        }

        function onMouseMove(event) {
            if (!isDragging) return;
            const point = getRayIntersection(event.clientX, event.clientY);
            if(point) {
                updateDragPosition(point);
            }
        }
        
        function onTouchMove(event) {
            if(!isDragging) return;
            event.preventDefault(); // 防止滚动
            const t = event.touches[0];
            const point = getRayIntersection(t.clientX, t.clientY);
            if(point) updateDragPosition(point);
        }

        function updateDragPosition(targetPoint) {
            // 限制拉拽距离
            const anchor = new THREE.Vector3(slingshotPos.x, slingshotPos.y + 1.5, slingshotPos.z);
            let dir = new THREE.Vector3().subVectors(targetPoint, anchor);
            // 锁定 Z 轴，只允许 XY 平面移动 (或是稍微允许一点 Z)
            dir.z = 0; 
            
            const len = dir.length();
            const maxDrag = 4;
            
            if(len > maxDrag) {
                dir.normalize().multiplyScalar(maxDrag);
            }
            
            // 更新鸟的视觉位置
            birdMesh.position.copy(anchor).add(dir);
            // 让鸟看着发射方向
            birdMesh.lookAt(anchor);
        }

        function onMouseUp() {
            if (isDragging) {
                isDragging = false;
                controls && (controls.enabled = true);

                // 计算发射向量
                const anchor = new THREE.Vector3(slingshotPos.x, slingshotPos.y + 1.5, slingshotPos.z);
                const pullVector = new THREE.Vector3().subVectors(anchor, birdMesh.position);
                
                // 力度系数
                const forceMultiplier = 8; 
                const velocity = pullVector.multiplyScalar(forceMultiplier);

                fireBird(birdMesh.position, new CANNON.Vec3(velocity.x, velocity.y, velocity.z));
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 游戏循环 ---

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() / 1000;
            if (!lastCallTime) {
                world.step(timeStep);
            } else {
                const dt = time - lastCallTime;
                world.step(timeStep, dt, 3);
            }
            lastCallTime = time;

            // 同步物理和视觉
            for (const obj of objectsToUpdate) {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            }

            // 简单的相机跟随 (可选)
            // if(birdFired && birdMesh.position.x > 0 && birdMesh.position.x < 30) {
            //     camera.position.x = THREE.MathUtils.lerp(camera.position.x, birdMesh.position.x, 0.1);
            //     camera.lookAt(birdMesh.position.x, 5, 0);
            // } else if (!birdFired) {
            //     // 回归原位
            //     // camera.position.set(0, 10, 35);
            //     // camera.lookAt(0, 5, 0);
            // }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
