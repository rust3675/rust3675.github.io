<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alpaca & Giant Mecha Quetzalcoatlus</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* æ›´äº®çš„å¤©ç©ºè“ */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            pointer-events: none;
            transition: opacity 0.5s;
        }
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            pointer-events: none;
            user-select: none;
            max-width: 250px;
        }
        h1 {
            margin: 0 0 5px 0;
            font-size: 18px;
            color: #333;
        }
        p {
            margin: 0;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="loading">åŠ è½½ä¸­...</div>
    <div class="controls-info">
        <h1>ç¾Šé©¼ & å·¨å‹æ³°å…‹é£ç¥ç¿¼é¾™</h1>
        <p>ğŸ–±ï¸ å·¦é”®æ‹–æ‹½ï¼šæ—‹è½¬è§†è§’</p>
        <p>ğŸ–±ï¸ å³é”®æ‹–æ‹½ï¼šå¹³ç§»è§†è§’</p>
        <p>ğŸ–±ï¸ æ»šè½®ï¼šç¼©æ”¾</p>
    </div>

    <!-- ä½¿ç”¨ Import Map æ–¹å¼å¼•å…¥æ¨¡å— -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 30, 120); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 10, 25); // è§†è§’æ‹‰è¿œä»¥å®¹çº³å·¨å‹ç”Ÿç‰©
        camera.lookAt(0, 5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 5;
        controls.maxDistance = 80;
        controls.target.set(0, 5, 0); // ä¸­å¿ƒç‚¹æŠ¬é«˜

        // --- ç¯å…‰ ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(20, 40, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096; // æé«˜é˜´å½±è´¨é‡
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        scene.add(dirLight);

        // ==========================================
        // æè´¨å®šä¹‰ (è¿˜åŸå›¾ç‰‡é…è‰²)
        // ==========================================
        
        // ç¾Šé©¼æè´¨
        const furMaterial = new THREE.MeshStandardMaterial({ color: 0xF8F8E7, roughness: 0.8 });
        const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xC0846A, roughness: 0.7 });
        const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x1A1A1A });
        const hoofMaterial = new THREE.MeshStandardMaterial({color: 0x4B372F, roughness: 0.7});

        // æ³°å…‹é£ç¥ç¿¼é¾™æè´¨ (å‚è€ƒå›¾ç‰‡ image_042c1e.png)
        // ä¸»ä½“æ·±è“è£…ç”²
        const tekBlueMat = new THREE.MeshStandardMaterial({ 
            color: 0x0044AA, 
            roughness: 0.3,
            metalness: 0.9,
        });
        // é¢ˆéƒ¨/å…³èŠ‚é’è‰² (Teal)
        const tekTealMat = new THREE.MeshStandardMaterial({ 
            color: 0x00FFFF, 
            roughness: 0.4,
            metalness: 0.7,
            emissive: 0x004444,
            emissiveIntensity: 0.2
        });
        // æ©™è‰²èƒ½é‡æ¿/ç¿¼å°– (Orange)
        const tekOrangeMat = new THREE.MeshStandardMaterial({ 
            color: 0xFF4500, 
            roughness: 0.2,
            metalness: 0.5,
            emissive: 0xFF2200,
            emissiveIntensity: 0.5
        });
        // ç´«è‰²èƒ½é‡å…‰æ•ˆ (çœ¼ç›/ç¼éš™)
        const tekPurpleLightMat = new THREE.MeshStandardMaterial({ 
            color: 0xFF00FF,
            emissive: 0xFF00FF,
            emissiveIntensity: 1.0
        });
        // æ·±è‰²æœºæ¢°éª¨æ¶
        const tekDarkMat = new THREE.MeshStandardMaterial({ 
            color: 0x222222, 
            roughness: 0.7,
            metalness: 0.8 
        });

        // ==========================================
        // 1. ç¾Šé©¼ (ä¿æŒåœ°é¢å‚ç…§ç‰©)
        // ==========================================
        const alpaca = new THREE.Group();
        alpaca.position.y = 1.0; 
        
        // ç®€åŒ–çš„ç¾Šé©¼æ„å»ºä»£ç 
        const bodyMain = new THREE.Mesh(new THREE.CapsuleGeometry(1.5, 3, 10, 20), furMaterial);
        bodyMain.rotation.z = Math.PI / 2; bodyMain.position.z = -0.5; 
        bodyMain.castShadow = true; alpaca.add(bodyMain);
        const bodyRear = new THREE.Mesh(new THREE.SphereGeometry(1.6, 16, 16), furMaterial);
        bodyRear.position.set(1.5, 0, -0.5); bodyRear.castShadow = true; alpaca.add(bodyRear);
        
        const neckGroup = new THREE.Group(); neckGroup.position.set(-1.8, 1, 0); alpaca.add(neckGroup);
        const neckMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.8, 4, 16), furMaterial);
        neckMesh.position.y = 2; neckMesh.castShadow = true; neckGroup.add(neckMesh);
        
        const headGroup = new THREE.Group(); headGroup.position.y = 4.2; neckGroup.add(headGroup);
        headGroup.add(new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), furMaterial));
        const snout = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 16), skinMaterial);
        snout.rotation.x = Math.PI / 2; snout.position.set(0, -0.3, 0.8); snout.castShadow = true; headGroup.add(snout);
        const earL = new THREE.Mesh(new THREE.CapsuleGeometry(0.15, 0.8, 4, 8), skinMaterial);
        earL.position.set(0.6, 0.8, -0.2); earL.rotation.z = -0.5; headGroup.add(earL);
        const earR = earL.clone(); earR.position.set(-0.6, 0.8, -0.2); earR.rotation.z = 0.5; headGroup.add(earR);
        
        function createAlpacaLeg(x, z) {
            const g = new THREE.Group(); g.position.set(x, 0, z);
            const up = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1.8, 8, 16), furMaterial); up.position.y = -0.9; up.castShadow = true; g.add(up);
            const low = new THREE.Mesh(new THREE.CapsuleGeometry(0.35, 1.5, 8, 16), skinMaterial); low.position.y = -2.5; low.castShadow = true; g.add(low);
            const hoof = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.5), hoofMaterial); hoof.position.y = -3.4; hoof.castShadow = true; g.add(hoof);
            return g;
        }
        const aLegFL = createAlpacaLeg(-1.2, 0.8); const aLegFR = createAlpacaLeg(-1.2, -0.8);
        const aLegBL = createAlpacaLeg(1.2, 0.8); const aLegBR = createAlpacaLeg(1.2, -0.8);
        alpaca.add(aLegFL, aLegFR, aLegBL, aLegBR);
        const aTail = new THREE.Mesh(new THREE.SphereGeometry(0.6, 12, 12), furMaterial);
        aTail.position.set(2.2, 0.8, 0); alpaca.add(aTail);

        scene.add(alpaca);

        // ==========================================
        // 2. å·¨å‹æ³°å…‹é£ç¥ç¿¼é¾™ (Giant Mecha Quetzal)
        // ==========================================
        const quetzal = new THREE.Group();
        quetzal.position.set(0, 12, 0); // é«˜ç©ºé£è¡Œ
        scene.add(quetzal);

        // æ•´ä½“ç¼©æ”¾ï¼Œè®©å®ƒçœ‹èµ·æ¥å·¨å¤§ (æ¯”ç¾Šé©¼å¤§å¾ˆå¤š)
        quetzal.scale.set(2.5, 2.5, 2.5);

        // > èº«ä½“ (Body) - æœºæ¢°è£…ç”²
        const qBodyGeo = new THREE.CapsuleGeometry(0.8, 2.5, 4, 16);
        const qBody = new THREE.Mesh(qBodyGeo, tekBlueMat);
        qBody.rotation.z = Math.PI / 2;
        qBody.castShadow = true;
        quetzal.add(qBody);

        // èƒŒéƒ¨è„Šæ¤ç»†èŠ‚ (é’è‰²)
        for(let i=0; i<6; i++) {
            const spine = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.4), tekTealMat);
            spine.position.set(-1 + i*0.4, 0.7, 0);
            spine.rotation.z = -0.2;
            quetzal.add(spine);
        }

        // > æœºæ¢°é¢ˆéƒ¨ (Neck) - å›¾ç‰‡ä¸­çš„åˆ†æ®µç»“æ„
        const qNeckGroup = new THREE.Group();
        qNeckGroup.position.set(-1.2, 0.2, 0);
        quetzal.add(qNeckGroup);

        const neckSegments = [];
        // å¼¯æ›²çš„é•¿è„–å­
        for(let i=0; i<8; i++) {
            const segGeo = new THREE.CylinderGeometry(0.35, 0.4, 0.8, 8);
            const mat = i % 2 === 0 ? tekTealMat : tekDarkMat; // é’è‰²å’Œæ·±è‰²äº¤æ›¿
            const seg = new THREE.Mesh(segGeo, mat);
            // æ¯ä¸€æ®µç¨å¾®æ—‹è½¬ï¼Œå½¢æˆSå½¢æ›²çº¿
            const segGroup = new THREE.Group();
            segGroup.position.x = -0.6; // æ¯ä¸€æ®µçš„ç›¸å¯¹ä½ç§»
            segGroup.rotation.z = i < 3 ? 0.1 : (i > 5 ? -0.1 : 0); // å‰æ®µå¾®æŠ¬ï¼Œåæ®µå¾®ä½
            
            if (i === 0) {
                qNeckGroup.add(segGroup);
            } else {
                neckSegments[i-1].add(segGroup);
            }
            
            seg.rotation.z = Math.PI / 2; // æ¨ªå‘åœ†æŸ±
            seg.castShadow = true;
            segGroup.add(seg);
            neckSegments.push(segGroup);
        }

        // > å¤´éƒ¨ (Head) - æå…¶ç²¾ç»†
        // è·å–è„–å­æœ€æœ«ç«¯çš„èŠ‚ç‚¹ä½œä¸ºå¤´éƒ¨æŒ‚è½½ç‚¹
        const headMount = neckSegments[neckSegments.length - 1];
        const qHeadGroup = new THREE.Group();
        qHeadGroup.position.set(-0.8, 0, 0); 
        headMount.add(qHeadGroup);

        // å¤´éª¨ä¸»ä½“ (è“è‰²)
        const qSkull = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.6, 0.5), tekBlueMat);
        qSkull.castShadow = true;
        qHeadGroup.add(qSkull);

        // çœ¼ç› (ç´«è‰²å‘å…‰æ¡)
        const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), tekPurpleLightMat);
        eyeL.position.set(-0.2, 0.1, 0.26);
        eyeL.rotation.z = 0.2;
        qHeadGroup.add(eyeL);
        const eyeR = eyeL.clone();
        eyeR.position.set(-0.2, 0.1, -0.26);
        qHeadGroup.add(eyeR);

        // æœºæ¢°å–™ (é•¿ä¸”å°–ï¼Œåˆ†ä¸ºä¸Šä¸‹ä¸¤éƒ¨åˆ†)
        const beakTop = new THREE.Mesh(new THREE.ConeGeometry(0.12, 3.5, 4), tekBlueMat);
        beakTop.rotation.z = Math.PI / 2;
        beakTop.position.set(-2.0, 0.1, 0);
        qHeadGroup.add(beakTop);

        const beakBot = new THREE.Mesh(new THREE.ConeGeometry(0.1, 3.0, 4), tekDarkMat);
        beakBot.rotation.z = Math.PI / 2;
        beakBot.position.set(-1.8, -0.15, 0);
        qHeadGroup.add(beakBot);

        // å·¨å¤§çš„å¤´å†  (Crest) - æ©™è‰²æ¿çŠ¶ï¼Œå‚è€ƒå›¾ç‰‡
        const crestGroup = new THREE.Group();
        crestGroup.position.set(0.2, 0.4, 0);
        qHeadGroup.add(crestGroup);

        const crestMain = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.0, 0.08), tekOrangeMat);
        crestMain.position.set(0, 0, 0);
        crestMain.rotation.z = 0.3; // å‘åå€¾æ–œ
        crestGroup.add(crestMain);
        
        // å¤´å† ä¸Šçš„è“è‰²è£…é¥°æ¡
        const crestDetail = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.2, 0.12), tekBlueMat);
        crestDetail.position.set(-0.2, -0.2, 0);
        crestDetail.rotation.z = 0.3;
        crestGroup.add(crestDetail);

        // > è…¿éƒ¨ (Legs) - é£è¡Œæ—¶å‘åæ”¶èµ·
        function createLeg(zDir) {
            const g = new THREE.Group();
            g.position.set(1.0, -0.5, 0.4 * zDir);
            const thigh = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.3, 0.3), tekTealMat);
            thigh.rotation.z = -0.5;
            g.add(thigh);
            const calf = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.2, 0.2), tekDarkMat);
            calf.position.set(0.8, -0.2, 0);
            calf.rotation.z = -0.2;
            g.add(calf);
            // çˆªå­
            const claw = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.3), tekOrangeMat);
            claw.position.set(1.4, -0.3, 0);
            g.add(claw);
            return g;
        }
        quetzal.add(createLeg(1), createLeg(-1));

        // > æœºæ¢°ç¿…è†€ (Wings) - å…³é”®éš¾ç‚¹
        // è¿˜åŸå›¾ç‰‡ä¸­çš„æ¿ç”²ç»“æ„ï¼šè“è‰²åº•åº§ + æ©™è‰²å°–ç«¯çš„åˆ†å±‚ç¾½ç¿¼
        const wingLGroup = new THREE.Group();
        const wingRGroup = new THREE.Group();
        wingLGroup.position.set(0.5, 0.5, 0.6);
        wingRGroup.position.set(0.5, 0.5, -0.6);
        quetzal.add(wingLGroup, wingRGroup);

        function createMechaWing(isLeft) {
            const root = new THREE.Group();
            const zSign = isLeft ? 1 : -1;

            // 1. ä¸Šè‡‚ (Arm)
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.5, 0.4), tekBlueMat);
            arm.rotation.x = (Math.PI / 2) * zSign;
            arm.position.z = 0.75 * zSign;
            root.add(arm);

            // 2. å‰è‡‚ (Forearm)
            const forearmGroup = new THREE.Group();
            forearmGroup.position.z = 1.5 * zSign; // æ¥åœ¨ä¸Šè‡‚æœ«ç«¯
            arm.add(forearmGroup);

            const forearm = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2.0, 0.3), tekTealMat);
            forearm.position.y = 1.0;
            forearmGroup.add(forearm);

            // 3. ç¿¼æŒ‡éª¨æ¶ (Wing Finger) - æé•¿ï¼Œå‘åå»¶ä¼¸
            const fingerGroup = new THREE.Group();
            fingerGroup.position.y = 2.0; // æ¥åœ¨å‰è‡‚æœ«ç«¯
            // é£è¡Œæ—¶ï¼Œæ‰‹æŒ‡å±•å¼€
            fingerGroup.rotation.z = -1.8; // å‘åæŠ˜
            forearmGroup.add(fingerGroup);

            const fingerBone = new THREE.Mesh(new THREE.BoxGeometry(0.2, 6.0, 0.2), tekDarkMat);
            fingerBone.position.y = 3.0;
            fingerGroup.add(fingerBone);

            // 4. æœºæ¢°ç¾½ç¿¼æ¿ç”² (Blades)
            // å›¾ç‰‡æ˜¾ç¤ºæœ‰å¤šä¸ªåˆ†æ®µçš„æ¿ç”²ï¼Œè“è‰²ä¸ºä¸»ï¼Œæœ«ç«¯æ©™è‰²
            const bladeCount = 5;
            for(let i=0; i<bladeCount; i++) {
                const bladeGroup = new THREE.Group();
                // æ²¿æ‰‹æŒ‡éª¨æ¶åˆ†å¸ƒ
                bladeGroup.position.y = 1.0 + i * 1.2; 
                fingerGroup.add(bladeGroup);

                // æ¯ä¸€ç‰‡æ¿ç”²çš„è§’åº¦é€æ¸å˜åŒ–ï¼Œå½¢æˆæ‰‡å½¢
                bladeGroup.rotation.z = 0.2 + i * 0.1; 
                // ç¨å¾®é”™å¼€Zè½´é˜²æ­¢ç©¿æ¨¡
                bladeGroup.position.z = i * 0.02 * zSign;

                // è“è‰²åº•æ¿
                const bladeBaseGeo = new THREE.BoxGeometry(1.5, 1.1, 0.05);
                // è°ƒæ•´å‡ ä½•ä½“ä¸­å¿ƒï¼Œä½¿å…¶ä»éª¨æ¶è¾¹ç¼˜å»¶ä¼¸
                bladeBaseGeo.translate(0.75, 0, 0); 
                const bladeBase = new THREE.Mesh(bladeBaseGeo, tekBlueMat);
                bladeGroup.add(bladeBase);

                // æ©™è‰²å°–ç«¯
                const bladeTipGeo = new THREE.BoxGeometry(0.8, 1.0, 0.06);
                bladeTipGeo.translate(0.4, 0, 0); // ç›¸å¯¹ä½ç§»
                const bladeTip = new THREE.Mesh(bladeTipGeo, tekOrangeMat);
                bladeTip.position.x = 1.5; // æ¥åœ¨è“è‰²åº•æ¿æœ«ç«¯
                bladeGroup.add(bladeTip);
            }

            return root;
        }

        const wingL = createMechaWing(true);
        const wingR = createMechaWing(false);
        wingLGroup.add(wingL);
        wingRGroup.add(wingR);


        // --- ç¯å¢ƒ ---
        const ground = new THREE.Mesh(new THREE.CylinderGeometry(35, 35, 80, 32), new THREE.MeshStandardMaterial({ color: 0x7CFC00, roughness: 0.9 }));
        ground.rotation.z = Math.PI / 2;
        ground.position.y = -40; 
        ground.receiveShadow = true;
        scene.add(ground);

        function createCloud(x, y, z, scale) {
            const g = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xF0F8FF, roughness: 0.5 });
            [[0,0,0,1.5], [1.2,0.3,-0.5,1.2], [-1,-0.2,0.3,1], [0.5,-0.5,1,0.8]].forEach(p => {
                const m = new THREE.Mesh(new THREE.SphereGeometry(p[3], 8, 8), mat);
                m.position.set(p[0], p[1], p[2]); g.add(m);
            });
            g.position.set(x, y, z); g.scale.setScalar(scale);
            scene.add(g);
            return g;
        }
        const clouds = [createCloud(18,15,-10,1.8), createCloud(-15,18,-15,2.2), createCloud(0,20,10,1.5)];

        // --- åŠ¨ç”»é€»è¾‘ ---
        const clock = new THREE.Clock();
        const speed = 10;

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // === ç¾Šé©¼åŠ¨ç”» (å¥”è·‘) ===
            const aLegAngle = Math.sin(time * speed) * 0.6;
            aLegFL.rotation.x = aLegAngle; aLegBL.rotation.x = aLegAngle * 0.8;
            aLegFR.rotation.x = -aLegAngle; aLegBR.rotation.x = -aLegAngle * 0.8;
            aLegFL.position.y = 0.5 + Math.sin(time * speed * 2) * 0.2;
            aLegFR.position.y = 0.5 + Math.sin(time * speed * 2 + Math.PI) * 0.2;
            alpaca.position.y = 1.0 + Math.sin(time * speed * 2) * 0.15;
            neckGroup.rotation.x = Math.sin(time * speed + Math.PI/2) * 0.1 - 0.2;

            // === å·¨å‹æ³°å…‹ç¿¼é¾™åŠ¨ç”» (é£è¡Œ) ===
            const flySpeed = 2.5; // å·¨å‹ç”Ÿç‰©æ‰‡ç¿…è†€è¾ƒæ…¢ä½†æœ‰åŠ›
            
            // 1. ç¿…è†€æ‰‡åŠ¨ (Flapping)
            // åˆ†ä¸ºä¸Šè‡‚ã€å‰è‡‚ã€æ‰‹æŒ‡çš„ä¸‰æ®µå¼æ‰‡åŠ¨
            const flapBase = Math.sin(time * flySpeed);
            
            // å·¦ç¿¼
            wingLGroup.rotation.z = flapBase * 0.4 - 0.2; // æ•´ä½“ä¸Šä¸‹
            wingL.children[0].children[0].rotation.z = flapBase * 0.2; // å‰è‡‚å¾®è°ƒ
            
            // å³ç¿¼ (é•œåƒ)
            wingRGroup.rotation.z = -flapBase * 0.4 + 0.2;
            wingR.children[0].children[0].rotation.z = -flapBase * 0.2;

            // 2. èº«ä½“æµ®åŠ¨
            quetzal.position.y = 12 + Math.sin(time * 1.5) * 1.5;
            
            // 3. é¢ˆéƒ¨åŠ¨æ€ (Så‹è •åŠ¨)
            neckSegments.forEach((seg, i) => {
                seg.rotation.z = Math.sin(time * 2 + i * 0.5) * 0.05;
            });

            // 4. ç›˜æ—‹ç§»åŠ¨ (Circle)
            const circleRadius = 10;
            quetzal.position.x = Math.sin(time * 0.5) * circleRadius;
            quetzal.position.z = Math.cos(time * 0.5) * circleRadius;
            quetzal.rotation.y = -time * 0.5 - Math.PI / 2; // é¢å‘åˆ‡çº¿æ–¹å‘

            // === ç¯å¢ƒ ===
            ground.rotation.x -= 0.03;
            clouds.forEach((c, i) => {
                c.position.x -= 0.1;
                if(c.position.x < -35) c.position.x = 35;
            });

            controls.update();
            renderer.render(scene, camera);
        }

        document.getElementById('loading').style.display = 'none';
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
